import { useState } from "react";
import JSZip from "jszip";
import Navbar from "../components/Navbar";
import Footer from "../components/Footer";
import UnlockWrapper from "../components/UnlockWrapper";

export default function DevTools() {
  const [botName, setBotName] = useState("NightBot");
  const [runtime, setRuntime] = useState("node");
  const [commands, setCommands] = useState([
    { cmd: "/start", reply: "Welcome to NightBot!" },
    { cmd: "/help", reply: "Here are the commands: /start, /help, /status, /ping" },
  ]);
  const [codeIn, setCodeIn] = useState("// paste code here");
  const [changeReq, setChangeReq] = useState("");
  const [codeOut, setCodeOut] = useState("");
  const [cloneNote, setCloneNote] = useState("");
  const [cloneFile, setCloneFile] = useState(null);

  function addCommand() {
    setCommands([...commands, { cmd: "", reply: "" }]);
  }

  function escapeForRegex(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function genBotCode() {
    if (runtime === "node") {
      return `// ${botName} - NightForge Generated Node.js Bot
const TelegramBot = require('node-telegram-bot-api');
const bot = new TelegramBot(process.env.BOT_TOKEN || 'YOUR_TOKEN', { polling: true });

// Commands
${commands
  .map(
    (c) => `bot.onText(/${escapeForRegex(c.cmd)}/, (msg) => {
  bot.sendMessage(msg.chat.id, \`${c.reply}\`);
});`
  )
  .join("\n\n")}`;
    } else {
      return `# ${botName} - NightForge Generated Python Bot
from aiogram import Bot, Dispatcher, types
from aiogram.utils import executor
import os

bot = Bot(token=os.getenv("BOT_TOKEN") or "YOUR_TOKEN")
dp = Dispatcher(bot)

${commands
  .map(
    (c) => `@dp.message_handler(commands=["${c.cmd.replace("/", "")}"])
async def cmd_${c.cmd.replace("/", "")}(message: types.Message):
    await message.reply("${c.reply}")`
  )
  .join("\n\n")}
      
if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)`;
    }
  }

  function applyModification() {
    const header = "// Modified by NightForge: " + (changeReq || "Minor fix");
    setCodeOut(header + "\n" + codeIn + "\n\n// NOTE: manual review required.");
  }

  async function buildBotZip() {
    if (!botName) return alert("Set a bot name");
    const zip = new JSZip();
    zip.file("README.md", `# ${botName}\n\nGenerated by NightForge.\n`);
    zip.file(runtime === "node" ? "bot.js" : "bot.py", genBotCode());
    zip.file("commands.json", JSON.stringify(commands, null, 2));
    if (cloneFile) {
      zip.file(cloneFile.name, await cloneFile.arrayBuffer());
    }
    const blob = await zip.generateAsync({ type: "blob" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${botName}_NightForge.zip`;
    link.click();
  }

  return (
    <>
      <Navbar />
      <UnlockWrapper>
        <main className="container section">
          <h1 className="section-title">ðŸ’€ Dev Tools â€” NightForge</h1>

          {/* BOT BUILDER */}
          <section className="card">
            <h3 className="card-title">ðŸ¤– Telegram Bot Builder</h3>

            <label>Bot Name
              <input className="input" value={botName} onChange={(e) => setBotName(e.target.value)} />
            </label>

            <label>Runtime
              <select className="input" value={runtime} onChange={(e) => setRuntime(e.target.value)}>
                <option value="node">Node.js</option>
                <option value="python">Python</option>
              </select>
            </label>

            <div className="form-row">
              <strong>Commands</strong>
              {commands.map((c, i) => (
                <div key={i} className="form-row">
                  <input className="input" value={c.cmd} placeholder="/cmd"
                    onChange={(e) => {
                      const arr = [...commands];
                      arr[i].cmd = e.target.value;
                      setCommands(arr);
                    }} />
                  <input className="input" value={c.reply} placeholder="Reply text"
                    onChange={(e) => {
                      const arr = [...commands];
                      arr[i].reply = e.target.value;
                      setCommands(arr);
                    }} />
                </div>
              ))}
              <button onClick={addCommand} className="btn">+ Add Command</button>
            </div>

            <h4 className="card-subtitle">Generated Code</h4>
            <pre className="code-block">{genBotCode()}</pre>

            <button onClick={buildBotZip} className="btn">ðŸ’¾ Download Bot ZIP</button>
          </section>

          {/* CODE MODIFIER */}
          <section className="card">
            <h3 className="card-title">ðŸ›  Code Modifier</h3>
            <textarea rows={8} className="code-input" value={codeIn} onChange={e => setCodeIn(e.target.value)} />
            <input className="input" placeholder="Describe change..." value={changeReq} onChange={e => setChangeReq(e.target.value)} />
            <button className="btn" onClick={applyModification}>Apply Modifier</button>
            {codeOut && <pre className="code-block">{codeOut}</pre>}
          </section>

          {/* BOT CLONER */}
          <section className="card">
            <h3 className="card-title">ðŸ“¦ Bot Cloner</h3>
            <p className="muted">Upload a bot ZIP â€” NightForge will repackage it.</p>
            <input type="file" accept=".zip"
              onChange={e => {
                setCloneFile(e.target.files[0]);
                setCloneNote(`Uploaded: ${e.target.files[0].name}`);
              }} />
            <p className="success-msg">{cloneNote}</p>
          </section>

          <p className="muted">Deploy Guides are included in ZIP when available. Always keep tokens secret.</p>
        </main>
      </UnlockWrapper>
      <Footer />
    </>
  );
}
